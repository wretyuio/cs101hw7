#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <Myro.h>
#include <math.h>
#include <stdio.h>
#include <cstdlib>
#include <sstream>
#include <Picture.h>
#include <Graphics.h>
#include "qrcode.h"
using namespace std;

qrcode::qrcode(PicturePtr pic, string playlist)
{
    xmin = 999999;
	xmax = 0;
	ymin = 999999;
	ymax = 0;
	type = 0;

	mainPic = pic;
	picWidth = pic->getWidth();
	picHeight = pic->getHeight();
	isYellow=0;
	playlistName = playlist;
}

int qrcode::min(int min, int point)
{
	if ( point<min ) //if the point is smaller than the original min
		return point; //make the point to be the new min
	else
		return min; //keep the original min
}

int qrcode::max(int max, int point)
{
	if ( point>max ) //if the point is bigger than the original max
		return point; //make the point to be the new max
	else
		return max; //keep the original max
}

int qrcode::getXMin()
{
	return xmin;
}
int qrcode::getXMax()
{
	return xmax;
}
int qrcode::getYMin()
{
	return ymin;
}
int qrcode::getYMax()
{
	return ymax;
}
int qrcode::getType()
{
	return type;
}
int qrcode::setType(int number)
{
	type=number;
}
int qrcode::getHeight()
{
	int qrHeight = ymax-ymin;
	return qrHeight;
}
int qrcode::getWidth()
{
	int qrWidth = xmax-xmin;
	return qrWidth;
}
int qrcode::getArea()
{
	int area = getWidth()*getHeight();
	return area;
}

int qrcode::playlistArea()
{
	int area = (picWidth-1) * (picHeight-1);
	//area -= 100;
	return area;
}

void qrcode::DetectHelper(int x, int y, int** visitedMap)
{
	if ( blackWhite(x,y) && visitedMap[y][x]==0 )
	{
		// cout << "Detect Helper x: " << x << ", y: " << y << endl;
		xmin = min(x, xmin);
		xmax = max(x, xmax);
		ymin = min(y, ymin);
		ymax = max(y, ymax);
		visitedMap[y][x] = 1;

		if(x<picWidth-1) 
			DetectHelper(x+1, y+0, visitedMap);
		if(x>0) 
			DetectHelper(x-1, y+0, visitedMap);

		if(y<picHeight-1) 
			DetectHelper(x+0, y+1, visitedMap);
		if(y>0) 
			DetectHelper(x+0, y-1, visitedMap);
	}

	//cout<<"exiting detecthelper"<<endl;
}

bool qrcode::isBlack(int x, int y) //used this when looking for borders, but since this method didn't work when multiple qr outlines were overlapped, I ended up not using them
{
	Pixel black={0,0,0};
	Pixel temp = getPixel(mainPic, x, y);
	int dist = sqrt( pow( (black.R-temp.R), 2) + pow( (black.G-temp.G), 2) + pow( (black.B-temp.B),2) );
	int threshold=40;

	if (dist < threshold) 
		return true;
	else
		return false;
}

bool qrcode::Detect(int** visitedMap)
{
	bool found=false;
	for(int y=0; y<picHeight && !found; y++)
	{
		for(int x=0; x<picWidth && !found; x++)
		{
			if( blackWhite(x,y) && visitedMap[y][x]==0)
			{
				cout << endl;
				cout << "Detect x: " << x << ", y: " << y << endl;
				findColor(x,y, visitedMap);
				found=true;
				DetectHelper(x,y,visitedMap);
			}
		}
	}
	return found;
}

bool qrcode::findFirst(int x, int y) //finds first point of QR code, searches for background only
{
	Pixel red={214,43,8}; //R:207>221; G:39>48; B:1>16
	Pixel orange={236,183,109}; //R:231>240; G:180>185; B:100>118
	Pixel yellow={254,251,55}; //R:254>255; G:251>252; B:55>56
	Pixel darkGreen={137,249,60};  //R:137>138; G:248>250; B:59>61
	Pixel lightGreen={107,182,64};  //R:107; G:182; B:64
	Pixel green={122,215,62};
	Pixel blue={32,54,251};  //R:31>34; G:53>55; B:249>253
	Pixel purple={150,90,203}; //R:147>152; G:87>91; B:200>207

	Pixel temp = getPixel(mainPic, x, y);
	int d1 = sqrt( pow( (red.R-temp.R), 2) + pow( (red.G-temp.G), 2) + pow( (red.B-temp.B),2) );
	int d2 = sqrt( pow( (orange.R-temp.R), 2) + pow( (orange.G-temp.G), 2) + pow( (orange.B-temp.B),2) );
	int d3 = sqrt( pow( (yellow.R-temp.R), 2) + pow( (yellow.G-temp.G), 2) + pow( (yellow.B-temp.B),2) );
	int d4 = sqrt( pow( (darkGreen.R-temp.R), 2) + pow( (darkGreen.G-temp.G), 2) + pow( (darkGreen.B-temp.B),2) );
	int d5 = sqrt( pow( (lightGreen.R-temp.R), 2) + pow( (lightGreen.G-temp.G), 2) + pow( (lightGreen.B-temp.B),2) );
	int dg = sqrt( pow( (green.R-temp.R), 2) + pow( (green.G-temp.G), 2) + pow( (green.B-temp.B),2) );
	int d6 = sqrt( pow( (blue.R-temp.R), 2) + pow( (blue.G-temp.G), 2) + pow( (blue.B-temp.B),2) );
	int d7 = sqrt( pow( (purple.R-temp.R), 2) + pow( (purple.G-temp.G), 2) + pow( (purple.B-temp.B),2) );

	int threshold=100;
	//if ( temp.R > max(temp.G,temp.B) ) //red
	if ( d1 < threshold )
	{
		type = 1;
		return true;
	}
	//else if ( ((temp.R+(.4*temp.G))/1.4) > temp.B ) //orange
	else if ( d2 < threshold )
	{
		type = 6;
		return true;
	}
	//else if ( (.5*(temp.R+temp.G)) > temp.B) //yellow
	else if ( d3 < threshold)
	{
		type = 4;
		return true;
	}
	else if ( temp.G > max(temp.R,temp.B) ) //light green
	{
		type = 2;
		return true;
	}
	//else if ( ( temp.B > max(temp.R,temp.G) ) ) //blue
	else if (d6 < threshold)
	{
		type = 3;
		return true;
	}
	//else if ( (.5*(temp.B+temp.R)) > (temp.G) ) //purple
	else if ( d7 < threshold )
	{
		type = 5;
		return true;
	}
	else
		return false;
}

void qrcode::findColor(int x, int y, int** visitedMap) //finds first point of QR code, searches for background only
{
	cout<<"FINDCOLOUR"<<endl;
	Pixel red={214,43,8}; //R:207>221; G:39>48; B:1>16
	Pixel orange={236,183,109}; //R:231>240; G:180>185; B:100>118
	Pixel yellow={254,251,55}; //R:254>255; G:251>252; B:55>56
	Pixel darkGreen={137,249,60};  //R:137>138; G:248>250; B:59>61
	Pixel lightGreen={107,182,64};  //R:107; G:182; B:64
	Pixel green={122,215,62};
	Pixel blue={32,54,251};  //R:31>34; G:53>55; B:249>253
	Pixel purple={150,90,203}; //R:147>152; G:87>91; B:200>207

	Pixel temp = getPixel(mainPic, x, y);
	int d1 = sqrt( pow( (red.R-temp.R), 2) + pow( (red.G-temp.G), 2) + pow( (red.B-temp.B),2) );
	int d2 = sqrt( pow( (orange.R-temp.R), 2) + pow( (orange.G-temp.G), 2) + pow( (orange.B-temp.B),2) );
	int d3 = sqrt( pow( (yellow.R-temp.R), 2) + pow( (yellow.G-temp.G), 2) + pow( (yellow.B-temp.B),2) );
	int d4 = sqrt( pow( (darkGreen.R-temp.R), 2) + pow( (darkGreen.G-temp.G), 2) + pow( (darkGreen.B-temp.B),2) );
	int d5 = sqrt( pow( (lightGreen.R-temp.R), 2) + pow( (lightGreen.G-temp.G), 2) + pow( (lightGreen.B-temp.B),2) );
	int dg = sqrt( pow( (green.R-temp.R), 2) + pow( (green.G-temp.G), 2) + pow( (green.B-temp.B),2) );
	int d6 = sqrt( pow( (blue.R-temp.R), 2) + pow( (blue.G-temp.G), 2) + pow( (blue.B-temp.B),2) );
	int d7 = sqrt( pow( (purple.R-temp.R), 2) + pow( (purple.G-temp.G), 2) + pow( (purple.B-temp.B),2) );

	int threshold=125;
	//else if ( ( temp.B > max(temp.R,temp.G) ) ) //blue
	if ( temp.R<=50 && (temp.B > max(temp.R,temp.G) ) )
	{
		type = 3;
	}
	//if ( temp.R > max(temp.G,temp.B) ) //red
	else if  (( (.5*(temp.B+temp.R)) > (temp.G)) && (temp.B <=40))
	{
		type = 1;
	}
	//else if ( (.5*(temp.B+temp.R)) > (temp.G) ) //purple
	else if ( (.5*(temp.B+temp.R)) > (temp.G) )
	{
		if (playlistName=="Playlist1.jpg")
			type = 6;
		else
			type = 5;
	}
	else if ( temp.G > max(temp.R,temp.B) ) //light green
	{
		if (playlistName=="Playlist4.jpg")
			type = 4;
		else
			type = 2;
	}
	//else if ( (.5*(temp.R+temp.G)) > temp.B) //yellow
	else //if ( ((.5*(temp.R+temp.G)) > temp.B) && (temp.B > 70) && ( ((temp.R-temp.B)>=-20) || ((temp.R-temp.B)<=20)  ) )
	{
		triCross(x,y,visitedMap);
		if (isYellow==0) //triangle
			if (playlistName=="Playlist4.jpg")
				type = 2;
			else
				type=4;
	}
	
	cout<<"EXITING FIND COLOUR"<<endl;
}

void qrcode::triCross(int x, int y, int** visitedMap) //i used this to differentiate between qr type 4 and 6
{
	cout << "inside triCross x: " << x << " y: " << y << endl;
	if ( blackWhite(x,y)  && visitedMap[y][x]==0 )
	{
		cout << "	inside if" << endl;
		Pixel temp = getPixel(mainPic, x, y);
		if (x==250 && y==350)
			cout << "(250,350) R: "<< temp.R << " G: " << temp.G << " B: " << temp.B << endl;
		else if (x==720 && y==350)
			cout << "(250,350) R: "<< temp.R << " G: " << temp.G << " B: " << temp.B << endl;

		//else if ( temp.G > max(temp.R,temp.B) ) //triangle
		if ( (temp.R-temp.G)>=-10 && (temp.R-temp.G<=10) )//( temp.G > max(temp.R,temp.B) ) //triangle
		{
			type=4;
			visitedMap[y][x]==1;
			isYellow=0;
		}
		else if ( ( (temp.R<=50) && (temp.B>=200) ) || ( (.5*(temp.R+temp.G)) > temp.B)) //cross
		{
			type=6;
			visitedMap[y][x]==1;
			isYellow=1;
		}
		//if ( (temp.R<=50) && (temp.B>=200) ) //blue, triangle //temp.R<=50 && //cross
		else
		{
			visitedMap[y][x]==1;
			// if((x<picWidth-1) && x>1 && (y<picHeight-1) && y>1) 
			// {
			// 	triCross(x+1, y, visitedMap);
			// 	triCross(x-1, y, visitedMap);
			// 	triCross(x, y-1, visitedMap);
			// 	triCross(x, y+1, visitedMap);
			// }
			if((x<picWidth-1) && x>1 && (y<picHeight-1) && y>1)
			{
				triCross(x+1, y+1, visitedMap);
			}
		}
	}
	cout << "outside triCross" <<endl;
}

bool qrcode::blackWhite(int x, int y) //finds first point of QR code, searches for background only
{
	Pixel red={214,43,8}; //R:207>221; G:39>48; B:1>16
	Pixel orange={236,183,109}; //R:231>240; G:180>185; B:100>118
	Pixel yellow={254,251,55}; //R:254>255; G:251>252; B:55>56
	Pixel darkGreen={137,249,60};  //R:137>138; G:248>250; B:59>61
	Pixel lightGreen={107,182,64};  //R:107; G:182; B:64
	Pixel green={122,215,62};
	Pixel blue={32,54,251};  //R:31>34; G:53>55; B:249>253
	Pixel purple={150,90,203}; //R:147>152; G:87>91; B:200>207

	Pixel temp = getPixel(mainPic, x, y);
	int thisMax = max( max(temp.R,temp.G), temp.B);
	int thisMin = min( min(temp.R,temp.B), temp.B);

	if ( ((thisMax-thisMin)>=0) && ( (thisMax-thisMin)<=30) ) //if it is black or white
		return false;
	else return true;
}

bool qrcode::findNext(int x, int y) //finds the other points of the QR code
{
	Pixel red={214,43,8}; //R:207>221; G:39>48; B:1>16
	Pixel orange={236,183,109}; //R:231>240; G:180>185; B:100>118
	Pixel yellow={254,251,55}; //R:254>255; G:251>252; B:55>56
	Pixel darkGreen={137,249,60};  //R:137>138; G:248>250; B:59>61
	Pixel lightGreen={107,182,64};  //R:107; G:182; B:64
	Pixel green={122,215,62};
	Pixel blue={32,54,251};  //R:31>34; G:53>55; B:249>253
	Pixel purple={150,90,203}; //R:147>152; G:87>91; B:200>207

	Pixel temp = getPixel(mainPic, x, y);
	int d1 = sqrt( pow( (red.R-temp.R), 2) + pow( (red.G-temp.G), 2) + pow( (red.B-temp.B),2) );
	int d2 = sqrt( pow( (orange.R-temp.R), 2) + pow( (orange.G-temp.G), 2) + pow( (orange.B-temp.B),2) );
	int d3 = sqrt( pow( (yellow.R-temp.R), 2) + pow( (yellow.G-temp.G), 2) + pow( (yellow.B-temp.B),2) );
	int d4 = sqrt( pow( (darkGreen.R-temp.R), 2) + pow( (darkGreen.G-temp.G), 2) + pow( (darkGreen.B-temp.B),2) );
	int d5 = sqrt( pow( (lightGreen.R-temp.R), 2) + pow( (lightGreen.G-temp.G), 2) + pow( (lightGreen.B-temp.B),2) );
	int dg = sqrt( pow( (green.R-temp.R), 2) + pow( (green.G-temp.G), 2) + pow( (green.B-temp.B),2) );
	int d6 = sqrt( pow( (blue.R-temp.R), 2) + pow( (blue.G-temp.G), 2) + pow( (blue.B-temp.B),2) );
	int d7 = sqrt( pow( (purple.R-temp.R), 2) + pow( (purple.G-temp.G), 2) + pow( (purple.B-temp.B),2) );

	int threshold=150;
	if ( type==1 ) //red + yelow = heart
	{
		//if ((temp.R > max(temp.G,temp.B) || ( (.5*(temp.R+temp.G)) > temp.B)))
		if ( (d1<threshold) || (d3<threshold) )
			return true;
		else
			return false;
	}
	if ( type==2 ) //green + purple = circle
	{
		//if (( temp.G > max(temp.R,temp.B) ) || ( (.5*(temp.B+temp.R)) > (temp.G) ) )
		if ( ( temp.G > max(temp.R,temp.B) ) || ( d7 < threshold+50 ))
			return true;
		else
			return false;
	}
	if ( type==3 ) //orange + blue = star
	{
		if (( (1.4*(temp.R+(.4*temp.G))) > temp.B ) || ( temp.B > max(temp.R,temp.G) ))
			return true;
		else
			return false;
	}
	if ( type==4 ) //blue + yellow = triangle
	{
		if (( temp.B > max(temp.R,temp.G) ) || ( ( (.5*(temp.R+temp.G)) > temp.B)))
			return true;
		else
			return false;
	}
	if ( type==5 ) //purple + red = pentagon
	{
		if (( (.5*(temp.B+temp.R)) > (temp.G) ) || ( temp.R > max(temp.G,temp.B) ))
			return true;
		else
			return false;
	}
	if ( type==6 ) //orange + green = cross
	{
		if (( (1.4*(temp.R+(.4*temp.G))) > temp.B ) || ( temp.G > max(temp.R,temp.B) ))
			return true;
		else
			return false;
	}
}
